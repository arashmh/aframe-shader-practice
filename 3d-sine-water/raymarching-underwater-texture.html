<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Realistic Refractive Water</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        /* A subtle gradient background to act as the "sky" reflection */
        #canvas-container { width: 100vw; height: 100vh; background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%); }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // --- 1. VERTEX SHADER ---
    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec2 vUv;

        void main() {
            vUv = uv;
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPos = worldPosition.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
    `;

    // --- 2. FRAGMENT SHADER (Refraction & Absorption) ---
    const FRAGMENT_SHADER = `
        precision highp float;

        uniform float uTime;
        uniform vec3 uCameraPos;
        uniform vec3 uLightDir;
        uniform float uWaveSpeed;
        uniform float uWaveFreq;
        uniform float uWaveAmp;
        
        // Floor / Refraction Uniforms
        uniform sampler2D uFloorTex;
        uniform float uFloorY; // Depth of the floor
        uniform vec3 uWaterColor; // Base water tint

        varying vec3 vWorldPos;

        // --- Wave Function ---
        float getWaveHeight(vec2 p) {
            float dist = length(p);
            float attenuation = 1.0 / (1.0 + dist * 0.1); 
            // Complex wave interference for realism
            float wave1 = sin(dist * uWaveFreq - uTime * uWaveSpeed);
            float wave2 = sin(p.x * uWaveFreq * 0.5 + uTime * uWaveSpeed * 0.8);
            return (wave1 + wave2) * 0.5 * uWaveAmp * attenuation;
        }

        // --- Raymarching Surface ---
        float intersectWater(vec3 ro, vec3 rd) {
            if (rd.y >= 0.0) return -1.0;
            float t = (0.3 - ro.y) / rd.y; // Start at y=0.3
            
            for(int i = 0; i < 40; i++) { // 40 steps is enough with damping
                vec3 p = ro + rd * t;       
                float h = getWaveHeight(p.xz); 
                float hDiff = p.y - h;      
                if(abs(hDiff) < 0.001) break;
                t += (hDiff / -rd.y) * 0.6; // Damping
            }
            return t;
        }

        vec3 getNormal(vec3 p) {
            float eps = 0.01;
            float h = getWaveHeight(p.xz);
            float hx = getWaveHeight(p.xz + vec2(eps, 0.0));
            float hz = getWaveHeight(p.xz + vec2(0.0, eps));
            return normalize(vec3(h - hx, eps, h - hz));
        }

        void main() {
            vec3 viewDir = normalize(vWorldPos - uCameraPos);
            
            // 1. Find Water Surface
            float t = intersectWater(uCameraPos, viewDir);
            if(t < 0.0) discard;

            vec3 hitPos = uCameraPos + viewDir * t;
            vec3 normal = getNormal(hitPos);
            vec3 lightDir = normalize(uLightDir);

            // --- 2. REFRACTION (The Wobble) ---
            // Snell's Law: Air (1.0) to Water (1.33) -> Ratio approx 0.75
            vec3 refractDir = refract(viewDir, normal, 0.75);
            
            // Trace the refracted ray down to the floor
            // Equation: hitPos + refractDir * tFloor = point on plane (y = uFloorY)
            // We need to find tFloor.
            float tFloor = (uFloorY - hitPos.y) / refractDir.y;
            
            vec3 floorHitPos = hitPos + refractDir * tFloor;
            
            // Map floor position to UVs (assuming 5x5 plane centered at 0,0)
            vec2 floorUV = (floorHitPos.xz / 5.0) + 0.5;
            
            // Sample the texture
            // Check if uv is within bounds (0-1) to avoid streaking at edges
            vec3 floorColor = vec3(0.0);
            if(floorUV.x >= 0.0 && floorUV.x <= 1.0 && floorUV.y >= 0.0 && floorUV.y <= 1.0) {
                 floorColor = texture2D(uFloorTex, floorUV).rgb;
            } else {
                 // Fallback color if ray refracts outside texture area
                 floorColor = vec3(0.1, 0.3, 0.5); 
            }

            // --- 3. ABSORPTION (Beer's Law) ---
            // Light travels from surface -> floor. Deeper water = darker/bluer.
            float depth = length(floorHitPos - hitPos);
            // Water absorbs Red fast, Green medium, Blue slow.
            vec3 absorptionFactor = vec3(0.8, 0.4, 0.1); 
            vec3 transmission = exp(-depth * absorptionFactor);
            
            vec3 finalRefractedColor = floorColor * transmission * uWaterColor;

            // --- 4. SURFACE REFLECTION (Fresnel) ---
            // Reflection of the "sky" (simple white/blue specular)
            float fresnel = pow(1.0 - max(dot(-viewDir, normal), 0.0), 3.0);
            
            // Specular Highlight (Sun)
            vec3 halfV = normalize(lightDir - viewDir);
            float spec = pow(max(dot(normal, halfV), 0.0), 200.0) * 1.5;

            // Mix Refracted Floor + Reflected Sky + Specular
            // Mix based on fresnel: angled view = more reflection, top-down = more refraction
            vec3 col = mix(finalRefractedColor, vec3(0.7, 0.9, 1.0), fresnel * 0.4);
            col += spec;

            gl_FragColor = vec4(col, 1.0);
            
            // Gamma
            gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0/2.2));
        }
    `;

    // --- SETUP ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 5, 4); // Top-down angled view
    
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- TEXTURE LOADER ---
    const loader = new THREE.TextureLoader();
    // Use a placeholder if the local file isn't found, but try the path requested.
    // Ideally, put a real image at ./assets/underwater-1.jpg
    const floorTexture = loader.load('./assets/underwater-1.jpeg', (tex) => {
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
    }, undefined, (err) => {
        console.warn("Texture not found at ./assets/underwater-1.jpg, using grid fallback.");
        // Generate a simple grid texture data if image fails
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#1a3b5c'; ctx.fillRect(0,0,512,512);
        ctx.strokeStyle = '#4fa3e0'; ctx.lineWidth = 5;
        ctx.beginPath();
        for(let i=0; i<=512; i+=64) { ctx.moveTo(i,0); ctx.lineTo(i,512); ctx.moveTo(0,i); ctx.lineTo(512,i); }
        ctx.stroke();
        floorTexture.image = canvas;
        floorTexture.needsUpdate = true;
    });

    // --- MESH ---
    const geometry = new THREE.PlaneGeometry(5, 5);
    
    const uniforms = {
        uTime: { value: 0 },
        uCameraPos: { value: new THREE.Vector3() },
        uLightDir: { value: new THREE.Vector3(1, 4, 2).normalize() },
        uWaterColor: { value: new THREE.Color(0xddeeff) }, // Tint for transmission
        
        // Physics
        uWaveSpeed: { value: 1.5 },
        uWaveFreq: { value: 7.0 },
        uWaveAmp: { value: 0.1 },
        
        // Floor
        uFloorTex: { value: floorTexture },
        uFloorY: { value: -0.7 } // 1m below y=0.3 is y=-0.7
    };

    const material = new THREE.ShaderMaterial({
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER,
        uniforms: uniforms,
        side: THREE.DoubleSide
    });

    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = 0.3; // Water surface level
    scene.add(plane);

    // --- GUI ---
    const gui = new GUI();
    const folder = gui.addFolder('Water Physics');
    folder.add(uniforms.uWaveAmp, 'value', 0.0, 0.3).name('Wave Height');
    folder.add(uniforms.uWaveFreq, 'value', 1.0, 20.0).name('Frequency');
    folder.add(uniforms.uWaveSpeed, 'value', 0.0, 5.0).name('Speed');
    
    const folder2 = gui.addFolder('Water Appearance');
    folder2.add(uniforms.uFloorY, 'value', -2.0, 0.0).name('Pool Depth');
    folder2.addColor({ c: 0xddeeff }, 'c').onChange(v => uniforms.uWaterColor.value.set(v)).name('Water Tint');
    
    folder.open();
    folder2.open();

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        uniforms.uTime.value = clock.getElapsedTime();
        uniforms.uCameraPos.value.copy(camera.position);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>