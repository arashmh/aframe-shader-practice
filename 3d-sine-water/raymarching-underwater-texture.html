<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Realistic Refractive Water with Stats</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%); }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    // 1. IMPORT STATS
    import Stats from 'three/addons/libs/stats.module.js';

    // --- VERTEX SHADER ---
    const VERTEX_SHADER = `
        varying vec3 vWorldPos;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPos = worldPosition.xyz;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
    `;

    // --- FRAGMENT SHADER ---
    const FRAGMENT_SHADER = `
        precision highp float;
        uniform float uTime;
        uniform vec3 uCameraPos;
        uniform vec3 uLightDir;
        uniform float uWaveSpeed;
        uniform float uWaveFreq;
        uniform float uWaveAmp;
        uniform sampler2D uFloorTex;
        uniform float uFloorY;
        uniform vec3 uWaterColor;
        varying vec3 vWorldPos;

        float getWaveHeight(vec2 p) {
            float dist = length(p);
            float attenuation = 1.0 / (1.0 + dist * 0.1); 
            float wave1 = sin(dist * uWaveFreq - uTime * uWaveSpeed);
            float wave2 = sin(p.x * uWaveFreq * 0.5 + uTime * uWaveSpeed * 0.8);
            return (wave1 + wave2) * 0.5 * uWaveAmp * attenuation;
        }

        float intersectWater(vec3 ro, vec3 rd) {
            if (rd.y >= 0.0) return -1.0;
            float t = (0.3 - ro.y) / rd.y; 
            for(int i = 0; i < 40; i++) { 
                vec3 p = ro + rd * t;       
                float h = getWaveHeight(p.xz); 
                float hDiff = p.y - h;      
                if(abs(hDiff) < 0.001) break;
                t += (hDiff / -rd.y) * 0.6; 
            }
            return t;
        }

        vec3 getNormal(vec3 p) {
            float eps = 0.01;
            float h = getWaveHeight(p.xz);
            float hx = getWaveHeight(p.xz + vec2(eps, 0.0));
            float hz = getWaveHeight(p.xz + vec2(0.0, eps));
            return normalize(vec3(h - hx, eps, h - hz));
        }

        void main() {
            vec3 viewDir = normalize(vWorldPos - uCameraPos);
            float t = intersectWater(uCameraPos, viewDir);
            if(t < 0.0) discard;

            vec3 hitPos = uCameraPos + viewDir * t;
            vec3 normal = getNormal(hitPos);
            vec3 lightDir = normalize(uLightDir);

            // Refraction
            vec3 refractDir = refract(viewDir, normal, 0.75);
            float tFloor = (uFloorY - hitPos.y) / refractDir.y;
            vec3 floorHitPos = hitPos + refractDir * tFloor;
            vec2 floorUV = (floorHitPos.xz / 5.0) + 0.5;
            
            vec3 floorColor = vec3(0.1, 0.3, 0.5); // Fallback
            if(floorUV.x >= 0.0 && floorUV.x <= 1.0 && floorUV.y >= 0.0 && floorUV.y <= 1.0) {
                 floorColor = texture2D(uFloorTex, floorUV).rgb;
            }

            // Absorption
            float depth = length(floorHitPos - hitPos);
            vec3 absorptionFactor = vec3(0.8, 0.4, 0.1); 
            vec3 transmission = exp(-depth * absorptionFactor);
            vec3 finalRefractedColor = floorColor * transmission * uWaterColor;

            // Reflection & Specular
            float fresnel = pow(1.0 - max(dot(-viewDir, normal), 0.0), 3.0);
            vec3 halfV = normalize(lightDir - viewDir);
            float spec = pow(max(dot(normal, halfV), 0.0), 200.0) * 1.5;

            vec3 col = mix(finalRefractedColor, vec3(0.7, 0.9, 1.0), fresnel * 0.4);
            col += spec;

            gl_FragColor = vec4(col, 1.0);
            gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0/2.2));
        }
    `;

    // --- SETUP ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 5, 4);
    
    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 2. INITIALIZE STATS
    const stats = new Stats();
    document.body.appendChild(stats.dom);

    const loader = new THREE.TextureLoader();
    const floorTexture = loader.load('./assets/underwater-1.jpeg', (tex) => {
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
    }, undefined, (err) => {
        const canvas = document.createElement('canvas');
        canvas.width = 512; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#1a3b5c'; ctx.fillRect(0,0,512,512);
        ctx.strokeStyle = '#4fa3e0'; ctx.lineWidth = 5;
        ctx.beginPath();
        for(let i=0; i<=512; i+=64) { ctx.moveTo(i,0); ctx.lineTo(i,512); ctx.moveTo(0,i); ctx.lineTo(512,i); }
        ctx.stroke();
        floorTexture.image = canvas;
        floorTexture.needsUpdate = true;
    });

    const geometry = new THREE.PlaneGeometry(5, 5);
    const uniforms = {
        uTime: { value: 0 },
        uCameraPos: { value: new THREE.Vector3() },
        uLightDir: { value: new THREE.Vector3(1, 4, 2).normalize() },
        uWaterColor: { value: new THREE.Color(0xddeeff) },
        uWaveSpeed: { value: 2.5 },
        uWaveFreq: { value: 7.0 },
        uWaveAmp: { value: 0.15 },
        uFloorTex: { value: floorTexture },
        uFloorY: { value: -0.4 }
    };

    const material = new THREE.ShaderMaterial({
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER,
        uniforms: uniforms,
        side: THREE.DoubleSide
    });

    const plane = new THREE.Mesh(geometry, material);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = 0.3; 
    scene.add(plane);

    const gui = new GUI();
    const folder = gui.addFolder('Water Physics');
    folder.add(uniforms.uWaveAmp, 'value', 0.0, 0.3).name('Wave Height');
    folder.add(uniforms.uWaveFreq, 'value', 1.0, 20.0).name('Frequency');
    folder.add(uniforms.uWaveSpeed, 'value', 0.0, 5.0).name('Speed');
    const folder2 = gui.addFolder('Water Appearance');
    folder2.add(uniforms.uFloorY, 'value', -2.0, 0.0).name('Pool Depth');
    folder2.addColor({ c: 0xddeeff }, 'c').onChange(v => uniforms.uWaterColor.value.set(v)).name('Water Tint');
    folder.open();
    folder2.open();

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        // 3. UPDATE STATS
        stats.update();

        uniforms.uTime.value = clock.getElapsedTime();
        uniforms.uCameraPos.value.copy(camera.position);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>