<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>4-Vertex Shader Water</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>

<!-- Import maps allow us to use ES modules from CDNs without a bundler -->
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

    // --- 1. VERTEX SHADER ---
    // This is minimal. It just puts the 4 vertices in place and passes data to the fragment shader.
    const vertexShader = `
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;

        void main() {
            vUv = uv;
            
            // Standard Three.js transformations
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPosition = worldPosition.xyz;
            
            vec4 mvPosition = viewMatrix * worldPosition;
            vViewPosition = -mvPosition.xyz;
            
            gl_Position = projectionMatrix * mvPosition;
        }
    `;

    // --- 2. FRAGMENT SHADER ---
    // This is where 100% of the magic happens per pixel.
    const fragmentShader = `
        precision highp float;

        uniform float uTime;
        uniform vec3 uColor;
        uniform vec3 uLightPos;
        uniform float uWaveSpeed;
        uniform float uWaveFreq;
        uniform float uWaveAmp;
        uniform float uSpecularPower;
        uniform float uSpecularIntensity;

        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;

        // Function to calculate the Wave Height and its Normal (slope)
        // We use Calculus here to be extremely fast (Analytic Derivatives)
        // rather than sampling neighbors.
        // Returns vec3(height, gradientX, gradientY)
        vec3 calculateWave(vec2 uv, float time) {
            vec2 center = vec2(0.5);
            vec2 p = uv - center;
            float dist = length(p);
            
            // Avoid division by zero at exact center
            if(dist == 0.0) return vec3(0.0, 0.0, 0.0);

            // The main wave function: Sine wave expanding from center
            // We dampen it (make it smaller) as it goes further out using (1.0 / (dist * ...))
            float phase = dist * uWaveFreq - time * uWaveSpeed;
            float attenuation = 1.0 / (1.0 + dist * 5.0); // Energy loss
            
            // The Height (Z)
            float height = sin(phase) * uWaveAmp * attenuation;

            // The Derivative (slope) calculation
            // d/dx (sin(kx - wt)) = k * cos(kx - wt)
            // We apply chain rule for the circular shape
            float deriv = cos(phase) * uWaveFreq * uWaveAmp * attenuation;
            
            // We also subtract the attenuation factor roughly to simulate slope lowering
            // simple version for speed:
            vec2 grad = (p / dist) * deriv; // Direction * Slope

            return vec3(height, grad.x, grad.y);
        }

        void main() {
            // 1. Calculate Wave Data
            vec3 wave = calculateWave(vUv, uTime);
            float h = wave.x;     // Height
            vec2 slope = wave.yz; // Gradients
            
            // 2. Construct the Fake Normal
            // If the surface is flat, Normal is (0,0,1).
            // Since we have a slope, we tilt the normal.
            // Using a larger Z value makes it look smoother/flatter.
            vec3 normal = normalize(vec3(-slope.x * 2.0, -slope.y * 2.0, 1.0));

            // 3. Lighting Setup
            vec3 viewDir = normalize(vViewPosition);
            
            // Simple Point Light logic (defined in world space relative to plane)
            vec3 lightDir = normalize(uLightPos - vWorldPosition);

            // 4. Blinn-Phong Specular (The "Wet" look)
            vec3 halfVector = normalize(lightDir + viewDir);
            float NdotH = max(0.0, dot(normal, halfVector));
            float specular = pow(NdotH, uSpecularPower) * uSpecularIntensity;

            // 5. Fresnel Effect (Water is more reflective at angles)
            float fresnel = pow(1.0 - max(0.0, dot(viewDir, normal)), 3.0);
            fresnel = clamp(fresnel, 0.0, 1.0);

            // 6. Combine Colors
            vec3 waterBase = uColor;
            
            // Add fake "sky" reflection based on Fresnel
            vec3 skyColor = vec3(0.8, 0.9, 1.0);
            vec3 finalColor = mix(waterBase, skyColor, fresnel * 0.5);
            
            // Add the specular highlight
            finalColor += vec3(specular);

            // Slight fake depth shadow based on wave height
            finalColor *= (0.9 + h * 2.0); 

            gl_FragColor = vec4(finalColor, 1.0);
            
            // Tone mapping approximation for brightness
            gl_FragColor.rgb = gl_FragColor.rgb / (gl_FragColor.rgb + vec3(1.0));
            gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(1.0/2.2)); // Gamma correction
        }
    `;

    // --- 3. SCENE SETUP ---
    const scene = new THREE.Scene();
    
    // Camera
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 4, 4); // Positioned to look down at an angle

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- 4. THE 4-VERTEX PLANE ---
    // PlaneGeometry(width, height, widthSegments, heightSegments)
    // 1, 1 segments ensures ONLY 4 vertices (2 triangles)
    const geometry = new THREE.PlaneGeometry(5, 5, 1, 1);

    // Uniforms object (data passed to shader)
    const uniforms = {
        uTime: { value: 0 },
        uColor: { value: new THREE.Color('#0049b6') },
        uLightPos: { value: new THREE.Vector3(2, 5, 2) },
        uWaveSpeed: { value: 3.0 },
        uWaveFreq: { value: 20.0 },
        uWaveAmp: { value: 0.15 },
        uSpecularPower: { value: 100.0 },
        uSpecularIntensity: { value: 2.0 }
    };

    const material = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: uniforms,
        side: THREE.DoubleSide // Ensure we see it from bottom too if needed
    });

    const plane = new THREE.Mesh(geometry, material);
    
    // Rotate -90 deg to lay flat on the "floor"
    plane.rotation.x = -Math.PI / 2;
    scene.add(plane);

    // Helper: Show where the "light" is (visual only)
    const lightHelperGeom = new THREE.SphereGeometry(0.1);
    const lightHelperMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const lightHelper = new THREE.Mesh(lightHelperGeom, lightHelperMat);
    lightHelper.position.copy(uniforms.uLightPos.value);
    scene.add(lightHelper);

    // --- 5. GUI CONTROLS ---
    const gui = new GUI();
    const params = {
        color: '#0049b6',
        lightX: 2, lightY: 5, lightZ: 2
    };

    gui.addColor(params, 'color').name('Water Color').onChange(v => uniforms.uColor.value.set(v));
    
    const folderWave = gui.addFolder('Wave Physics');
    folderWave.add(uniforms.uWaveSpeed, 'value', 0.0, 10.0).name('Speed');
    folderWave.add(uniforms.uWaveFreq, 'value', 1.0, 50.0).name('Frequency');
    folderWave.add(uniforms.uWaveAmp, 'value', 0.0, 0.5).name('Amplitude');
    folderWave.open();

    const folderLight = gui.addFolder('Lighting / Gloss');
    folderLight.add(uniforms.uSpecularPower, 'value', 10.0, 200.0).name('Sharpness');
    folderLight.add(uniforms.uSpecularIntensity, 'value', 0.0, 5.0).name('Intensity');
    folderLight.add(params, 'lightX', -10, 10).name('Light X').onChange(updateLight);
    folderLight.add(params, 'lightY', 0, 10).name('Light Y').onChange(updateLight);
    folderLight.add(params, 'lightZ', -10, 10).name('Light Z').onChange(updateLight);
    folderLight.open();

    function updateLight() {
        uniforms.uLightPos.value.set(params.lightX, params.lightY, params.lightZ);
        lightHelper.position.copy(uniforms.uLightPos.value);
    }

    // --- 6. ANIMATION LOOP ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        // Update time uniform
        uniforms.uTime.value = clock.getElapsedTime();

        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>